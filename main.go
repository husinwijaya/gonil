package main

import (
	"fmt"
	"os"
	"strings"

	"github.com/dave/jennifer/jen"
	"go/ast"
	"go/parser"
	"go/token"
	"path/filepath"
)

func main() {
	// 1. Handle arguments to command
	if len(os.Args) != 2 {
		fmt.Errorf("missing argument: <go source that contains type struct>")
	}
	fset := token.NewFileSet()
	sourceFile := os.Args[1]
	file, err := parser.ParseFile(fset, sourceFile, nil, parser.AllErrors)
	if err != nil {
		panic(err)
	}
	var genFile *jen.File
	var getImportPath func(string) string
	ast.Inspect(file, func(node ast.Node) bool {
		switch node.(type) {
		case *ast.File:
			curFile := node.(*ast.File)
			genFile = jen.NewFile(curFile.Name.Name)
			genFile.PackageComment("Code generated by generator, DO NOT EDIT.")
			getImportPath = func(alias string) string {
				for _, spec := range file.Imports {
					importPath := spec.Path.Value
					importPath = importPath[1 : len(importPath)-1]
					if strings.HasSuffix(importPath, "/"+alias) {
						return importPath
					}
				}
				return ""
			}
		case *ast.TypeSpec:
			t, ok := node.(*ast.TypeSpec)
			if !ok {
				return true
			}
			if t.Name == nil {
				fmt.Printf("type has no name\n")
				return true
			}
			s, ok := t.Type.(*ast.StructType)
			typeName := t.Name.Name
			if !ok {
				fmt.Printf("%s is not struct type\n", typeName)
				return true
			}
			fmt.Printf("found type %s\n", typeName)
			if s.Fields == nil {
				fmt.Printf("type %s has no field", typeName)
				return true
			}
			var nillableFields []jen.Code
			for _, field := range s.Fields.List {
				if field.Names == nil {
					switch field.Type.(type) {
					case *ast.Ident:
						nillableFields = append(nillableFields, jen.Op("*").Id(field.Type.(*ast.Ident).Name))
					}
				}
				for _, name := range field.Names {
					genField := jen.Id(name.Name)
					fieldType := field.Type
					switch fieldType.(type) {
					case *ast.Ident:
						genField = genField.Op("*").Id(fieldType.(*ast.Ident).Name)
					case *ast.SelectorExpr:
						fieldSel := fieldType.(*ast.SelectorExpr)
						x := fieldSel.X
						switch x.(type) {
						case *ast.Ident:
							genField = genField.Qual(getImportPath(x.(*ast.Ident).Name), fieldSel.Sel.Name)
						}
					}
					nillableFields = append(nillableFields, genField)
				}

			}
			fmt.Println("generating " + typeName)
			genFile.Type().Id(typeName + "Nillable").Struct(nillableFields...)
		}
		return true
	})
	ext := filepath.Ext(sourceFile)
	baseFilename := sourceFile[0 : len(sourceFile)-len(ext)]
	targetFilename := baseFilename + "_nillable.go"

	if err := genFile.Save(targetFilename); err != nil {
		panic(err)
	}
}
